<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Object-Oriented Design: A Comprehensive Guide to Building Robust and Scalable Software Systems</title>
      <link href="/general-oo-design/"/>
      <url>/general-oo-design/</url>
      
        <content type="html"><![CDATA[<blockquote><p>This blog is a second processed product/summary of the tutorial series:<br><a href="https://www.linkedin.com/learning/topics/object-oriented-programming">Linkedin Learning: Object-Oriented Programming</a>.<br>Bullet points extracted by me and reformatted with help from ChatGPT.</p></blockquote><p>Object-oriented design is a fundamental concept in software development that<br>focuses on modeling the behavior and characteristics of real-world objects in a program.<br>By understanding the basics of object identity, properties and attributes, behavior, and class, developers can create well-designed, efficient, and maintainable software.</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p><strong>Object Identity:</strong><br>Objects are unique entities within a program that are separate and distinguishable from one another, even if they belong to the same class or type. Each object has a unique identifier that differentiates it from other objects, and this identity is essential for managing and manipulating objects within a program.</p><p><strong>Properties and Attributes:</strong><br>Objects have properties or attributes that define their characteristics, such as size, weight, color, and shape. These attributes are essential for representing real-world objects in a program and can be used to distinguish between different objects of the same type.</p><p><strong>Behavior:</strong><br>Objects have behavior or actions that they can perform, such as filling, swimming, or ringing. Behavior is typically defined as methods or functions that manipulate an object’s attributes or interact with other objects in the program.</p><p>One of the challenges of object-oriented design is <strong>identifying what can be an object<br>in a program</strong>. In general, objects should be represented by nouns and not verbs,<br>and they should have a unique identity, attributes, and behavior. The focus should be on identifying the main objects in the program and their interactions with one another.</p><p>A class is a template for creating objects in a program. It defines the name, type, attributes, and behavior of objects that belong to that class. A class can be used to create multiple objects of the same type and is an essential component of object-oriented design.</p><h3 id="Steps-for-Object-Oriented-Design"><a href="#Steps-for-Object-Oriented-Design" class="headerlink" title="Steps for Object-Oriented Design"></a>Steps for Object-Oriented Design</h3><p>The process of object-oriented design involves analyzing and designing the program before writing the code.<br>This includes gathering requirements, describing the application, identifying the main objects, describing the interactions between objects, and creating a class diagram using Unified Modeling Language (UML).</p><h2 id="Software-System-Requirements"><a href="#Software-System-Requirements" class="headerlink" title="Software/System Requirements"></a>Software/System Requirements</h2><p>In object-oriented design, understanding the software/system requirements is essential for creating a<br>well-designed, efficient, and maintainable program.</p><h3 id="Sets-of-Requirements"><a href="#Sets-of-Requirements" class="headerlink" title="Sets of Requirements"></a>Sets of Requirements</h3><p>Software/system requirements can be divided into two sets of questions: </p><ul><li>what does it need to do? </li><li>how should it do it? </li></ul><p>The first set of questions refers to the functionality of the program, while the second set refers to performance, legal, support, and security requirements.</p><ul><li><p><strong>Function Requirements:</strong><br>refer to what the system/application must do. These requirements capture the bare necessities of the program and define the core functionality that the program needs to provide.</p></li><li><p><strong>Non-Functional Requirements:</strong><br>define how the system/application should do something. These requirements are concerned with aspects such as usability, reliability, performance, supportability, design, implementation, interface, and physical constraints.</p></li></ul><h3 id="FURPS-Requirement-Model"><a href="#FURPS-Requirement-Model" class="headerlink" title="FURPS Requirement Model"></a>FURPS Requirement Model</h3><p>The FURPS requirement model is a framework for thinking about software/system requirements.<br>FURPS stands for functionality, usability, reliability, performance, and supportability. </p><ul><li><p><strong>Functionality</strong><br>refers to the capabilities of the system, while the other four elements are non-functional requirements.</p></li><li><p><strong>Usability</strong><br>focuses on the user and include factors such as human factors UI and documentation.<br>The usability of the program is essential for ensuring that users can efficiently and effectively use the system.</p></li><li><p><strong>Reliability</strong><br>is concerned with predictability, availability, and failure rate.<br>These requirements ensure that the program operates consistently and reliably.</p></li><li><p><strong>Performance</strong><br>relates to speed, efficiency, and limitations. These requirements ensure that the program operates efficiently and effectively, even when processing large amounts of data.</p></li><li><p><strong>Supportability</strong><br>is concerned with extensibility, configurability, and testability. These requirements ensure that the program can be maintained and updated over time.</p></li></ul><p>Design, Implementation, Interface, and Physical Constraints<br>In addition to the FURPS requirements, other non-functional requirements include design (how the program is built), implementation (the programming language used and standards to follow), interface (the ability of the program to interface with other systems), and physical constraints (the hardware limitations of the system).</p><h2 id="Use-Case"><a href="#Use-Case" class="headerlink" title="Use Case"></a>Use Case</h2><p>The use case is a scenario that outlines a particular goal of an actor (user) with the system. It consists of the following elements:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[Title] </span><br><span class="line">    Short and simple goal</span><br><span class="line">[Primary Actor] </span><br><span class="line">    The user who desires to achieve the goal</span><br><span class="line">[Success Scenario] </span><br><span class="line">    Steps or paragraphs describing how to achieve the goal</span><br></pre></td></tr></table></figure><p>To create a use case,<br>identify the actors who interact with the system and separate them by their roles in the use case, not job titles.<br>Focus on the intent of the goal and not go into too specific steps or too broad a goal.<br>The scenario should be concise and avoid detailed technical implementation or UI elements.<br>Focus on the “sunny-day” scenario and avoid including rarely encountered scenarios.<br>Avoid needless words and keep the scenario short and concise.</p><h2 id="Conceptual-Model"><a href="#Conceptual-Model" class="headerlink" title="Conceptual Model"></a>Conceptual Model</h2><p>In object-oriented design, creating a conceptual model is a<br>crucial step in developing a software or system.<br>A conceptual model helps to identify the objects and their relationships that will form the backbone of the software.<br>Here are the steps involved in creating a conceptual model.</p><ul><li><p><strong>Identify Objects:</strong><br>The first step is to identify the objects that will be used as class objects in the system.<br>This can be done by looking at the user story or use case and picking out the relevant <strong>nouns.</strong> </p><ul><li>For example, in a user story about ordering a meal, the relevant objects might include “customer,” “menu,” and “order.”</li></ul></li></ul><ul><li><p><strong>Identify Class Relationships:</strong><br>Once the objects have been identified, the next step is to connect them with lines to show their relationships.<br>It is important to write down the <strong>verbs</strong> on each line to avoid using generic words like “use.”<br>Instead, use verbs that describe the relationship between the objects. </p><ul><li>For example, in the meal ordering system, the “customer” might “place” an “order” from the “menu.”</li></ul></li></ul><ul><li><p><strong>Figure Out Class Responsibilities:</strong><br>The final step is to figure out the responsibilities of each class.<br>This involves identifying the behaviors or actions that each class will perform.<br>This can be done by looking at the user story or use case and picking out the relevant verbs. </p><ul><li>For example, in the meal ordering system, the “menu” class might have the responsibility of “displaying” the available items while the “order” class might have the responsibility of “calculating” the total cost of the meal.</li></ul></li></ul><p>It is important to note that each behavior should belong to the class that is most responsible for it.<br>A behavior usually involves multiple objects, but each object should be responsible for itself.<br>Avoid putting too much responsibility on a single object, which can lead to a “god object” that controls everything in the system.</p><p>In addition to these steps, another useful tool for creating a conceptual model is CRC (Class Responsibility Collaboration) cards.<br>These cards can be used to organize the classes and their responsibilities, making it easier to visualize the system and identify any potential issues.</p><h2 id="Class-Diagram-and-Class-Relationship"><a href="#Class-Diagram-and-Class-Relationship" class="headerlink" title="Class Diagram and Class Relationship"></a>Class Diagram and Class Relationship</h2><p>In object-oriented design, UML class diagrams are used to represent the structure of a system’s classes and the relationships between them.<br>Here are some important considerations when creating UML class diagrams.</p><p>Each class in a UML class diagram should have a name, attributes, and behaviors.<br>When creating classes, it’s important to focus on the behaviors of the objects,<br>rather than just their attributes. This is because objects are meant to do things,<br>not just hold data.<br>In general, it’s recommended to keep as many class attributes and methods as private as possible,<br>only making them public if we are certain that other objects will need to use them.</p><p><strong>Constructor:</strong></p><p>Constructors are considered as behavior and should be treated as such when creating UML class diagrams.<br>In UML, a constructor is represented as a method with the same name as the class.</p><p><strong>Interface:</strong></p><p>In UML, abstract classes and interfaces are represented as types.<br>Abstract classes are used to represent a general category of objects,<br>while interfaces are used to represent shared capabilities or behaviors.<br>For example, a draw() interface can be shared between different types of objects that can be drawn on a screen.<br>While objects of different types cannot be categorized under the same abstract class,<br>they can all share the draw() interface to be able to draw on the screen.<br>A system can iterate through all objects and call the draw() interface to update the screen.</p><h2 id="Principles-and-Patterns"><a href="#Principles-and-Patterns" class="headerlink" title="Principles and Patterns"></a>Principles and Patterns</h2><p>There are several principles and patterns that can help make our software development more efficient and effective.</p><ol><li><p>Single Responsibility Principle: A class should have only one responsibility. Avoid creating god objects that try to do everything. Instead, split responsibilities into multiple classes.</p></li><li><p>Don’t Repeat Yourself (DRY): Avoid duplicating code. Reuse code and extract common functionality into methods or classes.</p></li><li><p>You Ain’t Gonna Need It (YAGNI): Don’t overdo it. Only add features that are necessary and useful. Avoid adding unnecessary complexity.</p></li><li><p>Error Handling and Prompt to Guide Users: Design our software to handle errors gracefully and provide clear prompts to guide users. Good error handling can improve the user experience and prevent bugs.</p></li><li><p>Software Testing: Testing is an important part of software development. Write automated tests to ensure that our code is working as intended and to catch regressions.</p></li><li><p>Design Patterns: Design patterns are reusable solutions to common software design problems. </p></li></ol><h3 id="Design-Pattern"><a href="#Design-Pattern" class="headerlink" title="Design Pattern"></a>Design Pattern</h3><p>They provide a template to help structure our code around.<br>One of the most well-known books on design patterns is <em>“Design Patterns: Elements of Reusable Object-Oriented Software”</em><br>by the “Gang of Four”, which describes 23 patterns.</p><ul><li><p><strong>Creational Patterns:</strong><br>These patterns deal with the instantiation of objects. Examples include Abstract Factory, Builder, Factory Method, Prototype, and Singleton.</p></li><li><p><strong>Structural Patterns:</strong><br>These patterns deal with how classes are designed and composed. Examples include Adapter, Bridge, Composite, Decorator, Facade, Flyweight, and Proxy.</p></li><li><p><strong>Behavioral Patterns:</strong><br>These patterns deal with communication between objects. Examples include Chain of Responsibility, Command, Interpreter, Iterator, Mediator, Memento, Observer, State, Strategy, Template Method, and Visitor.</p></li></ul><p>By following these principles and patterns, we can create software that is more modular, maintainable, and scalable.</p>]]></content>
      
      
      <categories>
          
          <category> learning log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pipeline </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Transform Your Workflow: Learn How to Convert Matrices between DCCs</title>
      <link href="/math-xform-conversion/"/>
      <url>/math-xform-conversion/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Have you noticed the different transform values when one asset is imported<br>to a different package?</p><p>When we do .fbx importing and exporting, the plugin does this conversion for<br>us. FBX is very reliable and hassle-free, but how does the math works?</p><blockquote><p><strong>Important:</strong> Before continuing, I highly recommend reading these previous posts</p><ul><li><a href="https://www.xingyulei.com/post/math-euler-gimbal/">Euler Angles</a></li><li><a href="https://www.xingyulei.com/post/math-change-of-basis/">Change of Basis</a></li></ul></blockquote><h2 id="Transformation-Value"><a href="#Transformation-Value" class="headerlink" title="Transformation Value"></a>Transformation Value</h2><p>To demonstrate the different transform between DCCs,<br>here I have some <em>‘axis’</em> object placed in Maya, Unity and Unreal.</p><p><img src="https://i.imgur.com/6z0QneT.jpg" alt="3in1" width="800px"></p><p>When inspecting the ‘axis’ located on the top-right, the transformation<br>values are seen as follow:</p><p><table style="width: 800px">  <tr>    <th></th>    <th>translation</th>    <th>rotation</th>    <th>scale</th>  </tr>  <tr>    <td>Maya</td>    <td>x: -1.31, y: 0.33, z: 0.19</td>    <td>x: -335, y: -12, z: 98</td>    <td>x: 1, y: 1, z: 1</td></tr>  <tr>    <td>Unity</td>    <td>x: 1.31, y: 0.33, z: 0.19</td>    <td>x: 7, y: -27, z: -102</td>    <td>x: 1, y: 1, z: 1</td>  </tr>  <tr>    <td>Unreal</td>    <td>x: -1.31, y: 0.19, z: 0.33</td>    <td>x: 149, y: 75, z: 123</td>    <td>x: 1, y: 1, z: 1</td>  </tr></table><br><br/></p><p>Usually, for translation and scale there is a pattern to be found, usually<br>the operation involves swapping values between axes, and flipping them. For<br>rotation, however, the values don’t seem to have connections between one<br>another, so how can we compute them?</p><p>The fundamental reason for all of this is that even though all DCCs use a<br>Cartesian coordinate system, they have different <strong>axis direction</strong> and <strong>rotation order</strong>.</p><h1 id="Methods-Overview"><a href="#Methods-Overview" class="headerlink" title="Methods Overview"></a>Methods Overview</h1><p>The method I use are all fundamental matrix calculation.</p><ol><li>From the source package, retrieve translation, rotation and scale ($t<em>{source}, r</em>{source}, s<em>{source}$)<br>and compose a transformation matrix: $M</em>{source}$</li></ol><ol><li>Convert the transformation matrix to the target software coordinate system<br>using change of basis operation: $M<em>{target} = M</em>{cob} <em> M_{source} </em> {M_{cob}}^{-1}$</li></ol><ol><li>Decompose the transformation matrix: $M<em>{target}$ and re-order the<br>target translation, rotation and scale value such ($t</em>{target}, r<em>{target}, s</em>{target}$)</li></ol><h2 id="Composition-and-De-composition"><a href="#Composition-and-De-composition" class="headerlink" title="Composition and De-composition"></a>Composition and De-composition</h2><p>It is helpful to re-visit the transform matrix calculation, but we will later<br>use a math library to handle them.</p><ul><li><p><strong>Translation</strong>:</p><p>a translating along $t = <d_x, d_y, d_z>$ can be thought as multiplying by<br>the translation matrix:<br>$<br>M_{translation} =<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; d_x\<br>0 &amp; 1 &amp; 0 &amp; d_y\<br>0 &amp; 0 &amp; 1 &amp; d_z\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>$</p></li><li><p><strong>Scale</strong>:</p><p>a scaling upon $s = &lt;\beta<em>x, \beta_y, \beta_z&gt;$ can be thought as multiplying<br>by the scale matrix:<br>$<br>M</em>{scale} =<br>\begin{bmatrix}<br>\beta_x &amp; 0 &amp; 0 &amp; 0\<br>0 &amp; \beta_y &amp; 0 &amp; 0\<br>0 &amp; 0 &amp; \beta_z &amp; 0\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>$</p></li><li><p><strong>Shear</strong>: good to know, but not very commonly use;<br>$sh = <sh_x, sh_y, sh_z>$ represents shear along <em>x</em>, <em>y</em> and <em>z</em> axis;</p><p>$<br>M<em>{sh_x} =<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0\<br>h</em>{yx} &amp; 1 &amp; 0 &amp; 0\<br>h<em>{zx} &amp; 0 &amp; 1 &amp; 0\<br>0 &amp; 0 &amp; 0 &amp; 1 \<br>\end{bmatrix}<br>$<br>$<br>M</em>{sh<em>y} =<br>\begin{bmatrix}<br>1 &amp; h</em>{xy} &amp; 0 &amp; 0\<br>0 &amp; 1 &amp; 0 &amp; 0\<br>0 &amp; h<em>{zy} &amp; 1 &amp; 0\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>$<br>$<br>M</em>{sh<em>z} =<br>\begin{bmatrix}<br>1 &amp; 0 &amp; h</em>{xz} &amp; 0\<br>0 &amp; 1 &amp; h_{yz} &amp; 0\<br>0 &amp; 0 &amp; 1 &amp; 0\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>$</p><blockquote><p><img src="https://i.stack.imgur.com/90xMH.jpg" alt="shear" width="400px"></p><p>A <strong>2D</strong> shearing operation</p></blockquote></li><li><p><strong>Rotation</strong>: a rotation can be thought as a combination of shearing and scaling,<br>a visual demonstration can be found <a href="https://youtu.be/E3Phj6J287o">here</a>.</p><p>A rotation along <em>x</em>, <em>y</em> and <em>z</em> axis can then be represented as such:</p><p>$<br>M<em>{r_x} =<br>\begin{bmatrix}<br>1 &amp; 0 &amp; 0 &amp; 0\<br>0 &amp; cos\theta &amp; -sin\theta &amp; 0\<br>0 &amp; sin\theta &amp; cos\theta &amp; 0\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>$<br>$<br>M</em>{r<em>y} =<br>\begin{bmatrix}<br>cos\theta &amp; 0 &amp; sin\theta &amp; 0\<br>0 &amp; 1 &amp; 0 &amp; 0\<br>-sin\theta &amp; 0 &amp; cos\theta &amp; 0\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>$<br>$<br>M</em>{r_z} =<br>\begin{bmatrix}<br>cos\theta &amp; -sin\theta &amp; 0 &amp; 0\<br>sin\theta &amp; cos\theta &amp; 0 &amp; 0\<br>0 &amp; 0 &amp; 1 &amp; 0\<br>0 &amp; 0 &amp; 0 &amp; 1<br>\end{bmatrix}<br>$</p></li></ul><h1 id="Real-Examples"><a href="#Real-Examples" class="headerlink" title="Real Examples"></a>Real Examples</h1><p>I used <code>numpy.ndarray</code> to store matrix, and used a third-party library<br>for computing the composition and de-composition of transformation matrix.</p><script src="https://gist.github.com/leixingyu/7496f9981c699a61ccf605c672898f9d.js"></script><h2 id="Computation"><a href="#Computation" class="headerlink" title="Computation"></a>Computation</h2><p>Now let’s put our code to the test:</p><p>Here are the transformation values I have in maya:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">maya_t = [-<span class="number">1.307</span>, <span class="number">0.331</span>, <span class="number">0.188</span>]</span><br><span class="line">maya_r = [-<span class="number">335</span>, -<span class="number">12</span>, <span class="number">98</span>]</span><br><span class="line">maya_s = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><h2 id="Maya-to-Unity"><a href="#Maya-to-Unity" class="headerlink" title="Maya to Unity"></a>Maya to Unity</h2><p>From the previous post, I’ve computed the change of basis matrix for Unreal</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MAYA_TO_UNITY = np.array([</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">], dtype=<span class="built_in">int</span>)</span><br></pre></td></tr></table></figure><p>Now followed by our methods:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">maya_matrix = compose_matrix(maya_t, maya_r, maya_s, order=<span class="string">&#x27;sxyz&#x27;</span>)</span><br><span class="line">unity_matrix = change_xform(maya_matrix, MAYA_TO_UNITY)</span><br><span class="line">unity_t, unity_r, unity_s = decompose_matrix(unity_matrix, order=<span class="string">&#x27;szxy&#x27;</span>)</span><br></pre></td></tr></table></figure><p>Result:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># transform in Unity</span></span><br><span class="line">translation = [<span class="number">1.307</span>, <span class="number">0.331</span>, <span class="number">0.188</span>] </span><br><span class="line">rotation = [<span class="number">7.3413883536944935</span>, -<span class="number">26.641453221201548</span>, -<span class="number">102.41010358310075</span>] </span><br><span class="line">scale = [<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>]</span><br></pre></td></tr></table></figure></p><p><strong>Important</strong>: for rotation since the returned values corresponds to the first, second<br>and third rotation angle specified in the rotation order:<br>which is in ‘zxy’, we need to swap values to re-order it as ‘xyz’.</p><h2 id="Maya-to-Unreal"><a href="#Maya-to-Unreal" class="headerlink" title="Maya to Unreal"></a>Maya to Unreal</h2><p>Same goes for Unreal, the change of basis matrix is:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MAYA_TO_UNREAL = np.array([</span><br><span class="line">    [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">], dtype=<span class="built_in">int</span>)</span><br></pre></td></tr></table></figure><p>Then comes our conversion method:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">maya_matrix = compose_matrix(maya_t, maya_r, maya_s, order=<span class="string">&#x27;sxyz&#x27;</span>)</span><br><span class="line">unreal_matrix = change_xform(maya_matrix, MAYA_TO_UNREAL)</span><br><span class="line">unreal_t, unreal_r, unreal_s = decompose_matrix(unreal_matrix, order=<span class="string">&#x27;sxyz&#x27;</span>)</span><br></pre></td></tr></table></figure><p>Result:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># transform in Unreal</span></span><br><span class="line">translation = [-<span class="number">1.307</span>, <span class="number">0.188</span>, <span class="number">0.331</span>] </span><br><span class="line">rotation = [<span class="number">149.05728077227823</span>, <span class="number">75.61041143412538</span>, <span class="number">123.21509334477231</span>] </span><br><span class="line">scale = [<span class="number">1.0</span>, <span class="number">1.0</span>, <span class="number">1.0</span>]</span><br></pre></td></tr></table></figure></p><p><strong>Caveat:</strong> I need to inverse the value of translation <em>z</em>, the reason I haven’t figured out yet,<br>but translation is hardly our concern since we just need to flip axes between Maya values;<br>The rotation value is the important one.</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://matthew-brett.github.io/transforms3d/index.html">Transform3d API</a></p><p><a href="https://discourse.threejs.org/t/convert-from-one-coordinate-system-to-another/13240">ThreeJS -<br>Convert from one coordinate system to another?</a></p><p><a href="https://www.techarthub.com/a-practical-guide-to-unreal-engine-4s-coordinate-system/">Tech Art Hub - A Practical Guide to Unreal Engine 4’s Coordinate System</a></p>]]></content>
      
      
      <categories>
          
          <category> learning log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> unreal </tag>
            
            <tag> unity </tag>
            
            <tag> maya </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A Key to Unlocking 3D Software: Understanding Change of Basis Matrix</title>
      <link href="/math-change-of-basis/"/>
      <url>/math-change-of-basis/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>Different DCCs uses coordinate systems with different axis directions. For example,<br>Maya by default uses a Y-up right-handed system; Unity uses a Y-up left-handed system;<br>and Unreal uses a Z-up left-handed system.</p><p><figure><br><img src="https://www.techarthub.com/wp-content/uploads/coordinate-comparison-chart-full.jpg" alt="dcc-coord" width="600px" ></p><p><figcaption>(Image from: Techart Hub)</figcaption><br>&lt;/figure&gt;<br><br></p><ul><li><p><strong>Up Direction</strong>: is what consider to be the up direction of the world. Moving<br>an object up translating in direction of positive <em>Y</em> in Maya and Unity, but for<br>Unreal, it’s translating in the direction of positive <em>Z</em>.</p></li><li><p><strong>Handed System</strong>: not only affects the forward/front direction of the world,<br>it also dictates the direction of rotation; for left-handed system,<br>positive rotation about the axis is <strong>clockwise</strong>, and for right-handed system, it’s<br><strong>counter-clockwise</strong> (same way as how our hand would curl, hence the name).</p></li></ul><p>The nature of the coordinate system affects how an object’s transformation is calculated.</p><p>The <strong>Change of Basis</strong> matrix transforms a vector lies in one coordinate system to<br>another.</p><h2 id="Basis-Vectors"><a href="#Basis-Vectors" class="headerlink" title="Basis Vectors"></a>Basis Vectors</h2><p>In the world of 2D, the basis vectors $x$ and $y$ of one coordinate system A,<br>corresponds to<br>$<br>v_x =<br>\begin{bmatrix}<br>1 \<br>0 \<br>\end{bmatrix}<br>$<br>and<br>$<br>v_y =<br>\begin{bmatrix}<br>0 \<br>1 \<br>\end{bmatrix}<br>$</p><p>Now, if these two basis vectors were to transfer to a different coordinate system B,<br>this exact set of basis vectors is written differently in that system.<br>This represents A’s basis vectors in B’s system.<br>$<br>v_x =<br>\begin{bmatrix}<br>2 \<br>1 \<br>\end{bmatrix}<br>$<br>and<br>$<br>v_y =<br>\begin{bmatrix}<br>-1 \<br>1 \<br>\end{bmatrix}<br>$</p><p>Correspondingly, any vector in system B could translate to system A, pre-multiply using this<br>change of basis matrix:<br>$<br>M_{cob} =<br>\begin{bmatrix}<br>2 &amp; -1\<br>1 &amp; 1\<br>\end{bmatrix}<br>$<br>where the first column is the basis vector $x$ and second column is the<br>basis vector $y$.</p><p>And alternatively, to translate any vector in system A to system B, we pre-multiply<br>by the inverse of this change of basis matrix: ${M_{cob}}^{-1}$.</p><h2 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h2><p>Now we know how to convert vectors between coordinate systems, how do we do it for transformation?<br>Here are some simple step to understand:</p><ol><li><p>Given any vector in system B, apply a change of basis operation, so it’s in system A: </p><p>$M_{cob} * v_B$.</p></li><li><p>Now we can apply a transformation represented in the same system A:</p><p>$M<em>{transformA} * M</em>{cob} * v_B$.</p></li><li><p>Finally, we can transfer the end result back to system B by pre-multiplying the inverse<br>of the change of basis matrix:</p><p> ${M<em>{cob}}^{-1} * M</em>{transformA} <em> M_{cob} </em> v_B$.</p></li></ol><p><br/></p><h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>The frontal part ${M<em>{cob}}^{-1} * M</em>{transformA} * M<em>{cob}$ represents the<br>same transformation but in system B: $M</em>{transformB}$.</p><p>Alternatively, any transformation in system B: $M<em>{transformB}$ can be represented<br>as $M</em>{cob} <em> M_{transformB} </em> {M_{cob}}^{-1}$ in system A.</p><p>Here’s the function I’ve written Python:</p><script src="https://gist.github.com/leixingyu/f8849105d509bd52723f3e94a35cab67.js"></script><h1 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h1><h2 id="Maya-to-Unreal"><a href="#Maya-to-Unreal" class="headerlink" title="Maya to Unreal"></a>Maya to Unreal</h2><p>The first thing to identify is the change of basis from Maya to Unreal,<br>as illustrated before, Maya is a Y-up left-hand system and Unreal is a Z-up<br>right-hand system. </p><table style="width: 500px"><tr>  <td colspan="6">Maya Axis Direction</td></tr>  <tr>    <td>Forward</td>    <td>Z</td>    <td>Up</td>    <td>Y</td>    <td>Right</td>    <td>-X</td>  </tr><tr>  <td colspan="6">Unreal Axis Direction</td></tr>  <tr>    <td>Forward</td>    <td>-Y</td>    <td>Up</td>    <td>Z</td>    <td>Right</td>    <td>-X</td>  </tr></table><p>The change of basis can be represented as such<br>  $<br>  M_{cob} =<br>  \begin{bmatrix}<br>  1 &amp; 0 &amp; 0 &amp; 0\<br>  0 &amp; 0 &amp; -1 &amp; 0\<br>  0 &amp; 1 &amp; 0 &amp; 0\<br>  0 &amp; 0 &amp; 0 &amp; 1<br>  \end{bmatrix}<br>  $</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MAYA_TO_UNREAL = np.array([</span><br><span class="line">    [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">], dtype=<span class="built_in">int</span>)</span><br></pre></td></tr></table></figure><h2 id="Maya-to-Unity"><a href="#Maya-to-Unity" class="headerlink" title="Maya to Unity"></a>Maya to Unity</h2><p>Same thing for Maya to Unity conversion, a Y-up left-hand system to a Y-up right-hand<br>system; the $y$ and $z$ are respectively inverted between the two systems, therefore:</p><table style="width: 500px"><tr>  <td colspan="6">Maya Axis Direction</td></tr>  <tr>    <td>Forward</td>    <td>Z</td>    <td>Up</td>    <td>Y</td>    <td>Right</td>    <td>-X</td>  </tr><tr>  <td colspan="6">Unity Axis Direction</td></tr>  <tr>    <td>Forward</td>    <td>Z</td>    <td>Up</td>    <td>Y</td>    <td>Right</td>    <td>X</td>  </tr></table><p>The change of basis can be represented as such<br>  $<br>  M_{cob} =<br>  \begin{bmatrix}<br>  -1 &amp; 0 &amp; 0 &amp; 0\<br>  0 &amp; 1 &amp; 0 &amp; 0\<br>  0 &amp; 0 &amp; 1 &amp; 0\<br>  0 &amp; 0 &amp; 0 &amp; 1<br>  \end{bmatrix}<br>  $</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">MAYA_TO_UNITY = np.array([</span><br><span class="line">    [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">], dtype=<span class="built_in">int</span>)</span><br></pre></td></tr></table></figure><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://youtu.be/P2LTAUO1TdA">YouTube - Change of basis | Chapter 13, Essence of linear algebra</a></p><p><a href="https://forums.unrealengine.com/t/forward-in-unreal-engine-which-is-it/93115">Unreal Engine Forum - “Forward” in unreal engine, Which is it?</a></p><p><a href="https://www.dariomazzanti.com/uncategorized/change-of-basis/">Dario Mazzanti - Change of Basis</a></p>]]></content>
      
      
      <categories>
          
          <category> 3d math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> unreal </tag>
            
            <tag> unity </tag>
            
            <tag> maya </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Euler Angles and Gimbal Lock: Things You Need to Know</title>
      <link href="/math-euler-gimbal/"/>
      <url>/math-euler-gimbal/</url>
      
        <content type="html"><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p>When talking about rotation, most of us would picture gimbal movement: an object<br>rotate about a set of three axes. This is the same principle of the Euler angles<br>presentation of rotation. It being the most popular representation for rotation,<br>is used across many DCCs, it is intuitive and easy for us to understand. </p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/d/d5/Gyroscope_operation.gif/220px-Gyroscope_operation.gif" alt="gimbal"></p><p>While an Euler angles are usually written as a list of three values representing<br>rotation degrees in <em>x</em>, <em>y</em>, <em>z</em> axis. </p><p>Scientifically it is actually denoted as<br>$\alpha$, $\beta$, $\gamma$ with radian as rotation unit where</p><ul><li>$\alpha$ is rotation about the first axis</li><li>$\beta$ is rotation about the second axis</li><li>$\gamma$ is rotation about the third axis</li></ul><h1 id="Rotation-Order"><a href="#Rotation-Order" class="headerlink" title="Rotation Order"></a>Rotation Order</h1><p>There are two major issue with Euler angles.</p><h2 id="Ambiguity"><a href="#Ambiguity" class="headerlink" title="Ambiguity"></a>Ambiguity</h2><p>The target orientation is rotation order dependent, meaning even with the<br>same rotation $\alpha$, $\beta$, $\gamma$ values,<br>the results differs using different order of rotation.</p><p>A <em>zyx</em> order refers to rotation about axis z, y, x in that order (think<br>of it as x axis being a child of y axis being a child of z axis).<br>Therefore, to represent a target rotation, aside from providing rotation values<br>$\alpha$, $\beta$, $\gamma$, we also need to provide<br>the rotation order and <a href="#rotation-type">Rotation Type</a>.</p><p>There are a total of 12 possible rotation orders per rotation type/group.</p><h2 id="Gimbal-Problem"><a href="#Gimbal-Problem" class="headerlink" title="Gimbal Problem"></a>Gimbal Problem</h2><p>In short, the Gimbal problem is due to euler angle decomposing a (linear) rotational movement<br>as a product of more than one axis rotations.</p><p>Although any target orientation can be achieved using Euler rotation, the rotational<br>movements are sometimes undesired. This is due to a problem in Animation field known as<br>Gimbal Lock.</p><table style="width: 900px">  <tr>    <td><img src="https://upload.wikimedia.org/wikipedia/commons/4/49/Gimbal_Lock_Plane.gif" alt="gimbal-lock" width="300px"></td>    <td>Gimbal lock happens when two of the three axes are rotated to a parallelconfiguration, 'locking' the system into a two-dimensional space.</td>  </tr></table><p><br></p><p>In order to “break free” of this configuration,<br>the system needs to input rotation along two or more axes simultaneously.</p><p>In the context of keyframe Animation, interpolation along more than one axis means the<br>rotational movement will not appear linear, but in an unpredictable trajectory,<br>which is bad. (See video illustration <a href="https://youtu.be/zc8b2Jo7mno?t=130">here</a>)</p><h3 id="Test-in-Maya"><a href="#Test-in-Maya" class="headerlink" title="Test in Maya"></a>Test in Maya</h3><p>We can test out the gimbal problem in Maya ourselves.</p><p>Going into rotation tools and select <em>“Axis Orientation”</em> to <em>“Gimbal”</em>, we can<br>now interact with the object using gimbal rotation. This rotation is what<br>actually get recorded by Maya and presented in the channel box.</p><p>If we go back to the <em>“Object”</em> mode rotation, even though our rotation gizmo is<br>now unlocked, the gimbal problem don’t just go away.<br>Maya is still recording the gimbal rotation in the background.<br>The <em>“Object”</em> mode rotation is just an interaction tool.</p><table style="width: 600px">  <tr>    <td><img src="https://i.imgur.com/wVrvepx.png" alt="gimbal" width="300px"></td>    <td><img src="https://i.imgur.com/jiUWIWa.png" alt="object" width="300px"></td>  </tr>  <tr>    <td>Gimbal Mode</td>    <td>Object Mode</td>  </tr></table><h2 id="Quaternion"><a href="#Quaternion" class="headerlink" title="Quaternion"></a>Quaternion</h2><blockquote><p>Rotation lies in non-Euclidean space.</p></blockquote><p>Luckily there is a more advanced representation for rotation: Quaternion, which<br>game engines uses internally. This is due to it being data compact (only stores four numbers) and<br>computational efficient (rotational movement using Euler angles usually need to be converted to rotation<br>matrix, which involves a lot of <em>sin</em> and <em>cos</em> calculation).</p><p>The bigger advantage comes from it<br>producing linear and predictable results (the shortest path along source and<br>target rotation). It is, however, very hard for users to comprehend.</p><p>A quaternion consists of a scaler part and a vector part:</p><p>  $q = [s, (x, y, z)]$ where $s, x, y, z \in R$</p><p>  or.<br>  $q = s + ix + ij + kz$ where $i^2 = j^2 = k^2 = ijk = -1$</p><h1 id="Rotation-Type"><a href="#Rotation-Type" class="headerlink" title="Rotation Type"></a>Rotation Type</h1><h2 id="Intrinsic-and-Extrinsic-Rotations"><a href="#Intrinsic-and-Extrinsic-Rotations" class="headerlink" title="Intrinsic and Extrinsic Rotations"></a>Intrinsic and Extrinsic Rotations</h2><p><strong>Intrinsic rotations</strong> are elemental rotations that occur about the axes of<br>a coordinate system XYZ attached to a moving body. (i.e. rotation about axis<br>in the current coordinate, like object space)</p><p><strong>Extrinsic rotations</strong> are elemental rotations that occur<br>about the axes of the fixed coordinate system xyz. (i.e. rotation about axis<br>in the original coordinate, like world space)</p><p><img src="https://img-blog.csdnimg.cn/fbc97c759b134aa3b87b1d3fa6bbc567.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBASGVyZW5lXw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="intrinsic-vs-extrinsic-rotation"></p><p>(Fig.1: Intrinsic rotations; Fig.2: Extrinsic rotations)</p><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>Rotation calculation usually happens along with other transform type using matrix.<br>Here I made a matrix composition and decomposition function in Python, utilizing<br>a third party math library <a href="http://matthew-brett.github.io/transforms3d/index.html">transforms3d</a>.</p><p>As we can see, since the rotation matrix varies depending on rotation order and type,<br>this is reflected as one of the argument. </p><script src="https://gist.github.com/leixingyu/7496f9981c699a61ccf605c672898f9d.js"></script><blockquote><p>The first character is ‘r’ (rotating == intrinsic),<br>or ‘s’ (static == extrinsic).</p><p>The next three characters give the axis (‘x’, ‘y’ or ‘z’)<br>about which to perform the rotation,<br>in the order in which the rotations will be performed.</p><p>For example the string ‘szyx’ specifies that the angles should be interpreted<br>relative to extrinsic (static) coordinate axes, and be performed in the order:<br>rotation about z axis; rotation about y axis; rotation about x axis.</p></blockquote><h2 id="Conversion"><a href="#Conversion" class="headerlink" title="Conversion"></a>Conversion</h2><p>Any extrinsic rotation can be represented in intrinsic rotation with the same<br>angle values but inverted order or elemental rotation.</p><p>So a $\alpha$, $\beta$, $\gamma$ with extrinsic <strong>zyx</strong> order is equivalent to<br>the same angle with intrinsic <strong>xyz</strong> order.</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="https://math.stackexchange.com/questions/2943074/">Stack Exchange - Confusion about order of rotations for Euler Angles</a></p><p><a href="https://forums.unrealengine.com/t/what-is-the-rotation-order-for-components-or-bones/286910/5">Unreal Engine Forum - What is the rotation order for Components or Bones?</a></p><p><a href="https://math.stackexchange.com/questions/1137745">Stack Exchange - Proof of the extrinsic to intrinsic rotation transform</a></p><p><a href="https://youtu.be/zc8b2Jo7mno">YouTube - Euler (Gimbal Lock) Explained</a></p><p><a href="http://td-matt.blogspot.com/2010/11/rotation-orders.html">TD Matt - Rotation Orders</a></p><p><a href="https://blog.csdn.net/weixin_42165913/article/details/120167295">CSDN - Understanding Euler Angles</a></p>]]></content>
      
      
      <categories>
          
          <category> 3d math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maya </tag>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Beginner&#39;s Guide to Graphics Lighting and Shading</title>
      <link href="/graphics-shading-basics/"/>
      <url>/graphics-shading-basics/</url>
      
        <content type="html"><![CDATA[<h3 id="Glossary"><a href="#Glossary" class="headerlink" title="Glossary"></a>Glossary</h3><p><a href="https://en.wikipedia.org/wiki/Glossary_of_computer_graphics">Wikipedia - Computer Graphics Glossary</a></p><p><strong>Shader</strong>: programs running on gpu that describes general computation (vertex transformation: vertex shader;<br>shading calculation: fragment shader)</p><p><strong>G-buffer</strong>: a screen space representation of geometry and material information (e.g. color, normal, position/depth)</p><p><strong>Fragment</strong>: is the corresponding pixel generated by geometric primitives,<br>but a pixel on screen can be a product of more than one fragment due to Z-buffering, blending etc.</p><h3 id="Vertex-lighting-vs-Per-pixel-lighting"><a href="#Vertex-lighting-vs-Per-pixel-lighting" class="headerlink" title="Vertex lighting vs. Per-pixel lighting"></a>Vertex lighting vs. Per-pixel lighting</h3><p><img src="https://www.researchgate.net/profile/Christoph-Guetter/publication/235696712/figure/fig1/AS:299742132228097@1448475501091/The-graphics-pipeline-in-OpenGL-consists-of-these-5-steps-in-the-new-generation-of-cards.png" alt="modern graphics pipeline"></p><h4 id="Vertex-Lighting"><a href="#Vertex-Lighting" class="headerlink" title="Vertex Lighting"></a>Vertex Lighting</h4><ul><li><p>Lighting is computed per-vertex</p></li><li><p>calculation happens in the vertex shader</p></li><li><p>lighting/color information is<br>then linearly interpolated across faces and rasterized</p></li><li><p>it is cheaper, faster (since there are fewer vertices compared to pixels) but noticeable artifact with low-poly objects</p></li></ul><h4 id="Per-Pixel-Lighting"><a href="#Per-Pixel-Lighting" class="headerlink" title="Per-Pixel Lighting"></a>Per-Pixel Lighting</h4><ul><li><p>Lighting is computed per-pixel/fragment (but what is this exactly? see the example below)</p></li><li><p>Calculation happens in the fragment shader</p></li><li><p>normal information (passed from vertex shader) is interpolated on the faces, lighting/color is calculated and rasterized.</p></li><li><p>it is more expensive but less artifact</p></li></ul><h3 id="Example-of-a-per-pixel-lighting-shader"><a href="#Example-of-a-per-pixel-lighting-shader" class="headerlink" title="Example of a per-pixel lighting shader"></a>Example of a per-pixel lighting shader</h3><h4 id="Vertex-Shader"><a href="#Vertex-Shader" class="headerlink" title="Vertex Shader"></a>Vertex Shader</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#version 330 core</span><br><span class="line">layout (location = 0) in vec3 aPos;</span><br><span class="line">layout (location = 1) in vec3 aNormal;</span><br><span class="line"></span><br><span class="line">out vec3 FragPos;</span><br><span class="line">out vec3 Normal;</span><br><span class="line"></span><br><span class="line">uniform mat4 model;</span><br><span class="line">uniform mat4 view;</span><br><span class="line">uniform mat4 projection;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    FragPos = vec3(model * vec4(aPos, 1.0));</span><br><span class="line">    Normal = mat3(transpose(inverse(model))) * aNormal;  </span><br><span class="line">    </span><br><span class="line">    gl_Position = projection * view * vec4(FragPos, 1.0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Fragment-Shader"><a href="#Fragment-Shader" class="headerlink" title="Fragment Shader"></a>Fragment Shader</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#version 330 core</span><br><span class="line">out vec4 FragColor;</span><br><span class="line"></span><br><span class="line">in vec3 Normal;  </span><br><span class="line">in vec3 FragPos;  </span><br><span class="line">  </span><br><span class="line">uniform vec3 lightPos; </span><br><span class="line">uniform vec3 viewPos; </span><br><span class="line">uniform vec3 lightColor;</span><br><span class="line">uniform vec3 objectColor;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">    // ambient</span><br><span class="line">    float ambientStrength = 0.1;</span><br><span class="line">    vec3 ambient = ambientStrength * lightColor;</span><br><span class="line">  </span><br><span class="line">    // diffuse </span><br><span class="line">    vec3 norm = normalize(Normal);</span><br><span class="line">    vec3 lightDir = normalize(lightPos - FragPos);</span><br><span class="line">    float diff = max(dot(norm, lightDir), 0.0);</span><br><span class="line">    vec3 diffuse = diff * lightColor;</span><br><span class="line">    </span><br><span class="line">    // specular</span><br><span class="line">    float specularStrength = 0.5;</span><br><span class="line">    vec3 viewDir = normalize(viewPos - FragPos);</span><br><span class="line">    vec3 reflectDir = reflect(-lightDir, norm);  </span><br><span class="line">    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32);</span><br><span class="line">    vec3 specular = specularStrength * spec * lightColor;  </span><br><span class="line">        </span><br><span class="line">    vec3 result = (ambient + diffuse + specular) * objectColor;</span><br><span class="line">    FragColor = vec4(result, 1.0);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>As we can see, fragment position and normal information are passed into the fragment shader<br>from vertex shader (where the pre-compute happens), the lighting calculation (Phong lighting)<br>is calculated per-fragment. </p><p>On a related note: gpu cost are related to </p><ol><li>how many vertices are passed in to the gpu from<br>buffer and </li><li>how complex the lighting calculation is in the fragment shader (this could be<br>the algorithm/model complexity, and the number of passes);</li></ol><hr><h3 id="Forward-vs-Deferred-Rendering"><a href="#Forward-vs-Deferred-Rendering" class="headerlink" title="Forward vs. Deferred Rendering"></a>Forward vs. Deferred Rendering</h3><h4 id="Forward-Rendering"><a href="#Forward-Rendering" class="headerlink" title="Forward Rendering"></a>Forward Rendering</h4><p>The standard, out-of-the-box rendering technique</p><p>Geometries are passed to gpu, going through vertex shader and fragment shader,<br>with each geometry and each light computed separately one at a time to form the final render.</p><p>Render complexity: O(num of geometry fragments * num of lights)</p><p><img src="https://cdn.tutsplus.com/cdn-cgi/image/width=600/gamedev/uploads/2013/11/forward-v2.png" alt="forward rendering"></p><h4 id="Deferred-Rendering"><a href="#Deferred-Rendering" class="headerlink" title="Deferred Rendering"></a>Deferred Rendering</h4><p>Render is deferred until all geometry has been processed</p><p>Geometries are passed to gpu, going through vertex shader and fragment shader (without lighting pass),<br>final rendering is computed/combined with multiple render passes<br>(one pass for getting all geometry information to G-buffer,<br>second pass for compute lighting based on the G-buffer).</p><p>Render complexity: O(screen resolution * num of lights)</p><p><img src="https://cdn.tutsplus.com/cdn-cgi/image/width=600/gamedev/uploads/2013/11/deferred-v2.png" alt="deferred rendering"></p><h4 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h4><p>Everything all comes down to lighting, as gpu can easily handle vertex information,<br>but the most expensive are lighting calculation which can easily slow down the rendering.<br>Forward rendering iterates and compute each fragments of each geometry, no matter if it overlaps or is hidden<br>by other fragments. So for each pixel, we could have already run multiple fragment shaders.</p><p>This is where deferred rendering come in handy, the G-buffer stores information such as color, normal and depth.<br>The lighting later on can know how to produce the final render by combining all the information (For example: depth test can<br>also cull out all the fragments that are being obscured). So essentially, each pixel only runs a single fragment shader.</p><hr><h3 id="Rasterization-vs-Ray-tracing"><a href="#Rasterization-vs-Ray-tracing" class="headerlink" title="Rasterization vs. Ray tracing"></a>Rasterization vs. Ray tracing</h3><p>The forward, deferred rendering techniques are all in the realm of rasterization, which is the<br>most popular and traditional real-time rendering technique. With the advance of hardware, ray tracing,<br>which is computationally demanding (usually used in films/animation) can now be used in<br>real-time video games.</p><h4 id="Rasterization"><a href="#Rasterization" class="headerlink" title="Rasterization"></a>Rasterization</h4><p>We gather objects information and projects each one by one on screen (per fragment), fragment shader<br>computes the final color of every fragment to form pixels on screen.</p><p>The fundamental of rasterizing is that for each object/geometry, we look at (rasterize it) it’s verts/triangles<br> to cover pixels.</p><p>So, as discussed in deferred rendering, every object is drawn but not all of them are displayed on screen.<br>This overdraw can be accelerated by using deferred shading’s depth test.</p><p><img src="https://www.scratchapixel.com/images/upload/rasterization/raytracing-raster5.png?" alt="rasterization"></p><h4 id="Ray-tracing"><a href="#Ray-tracing" class="headerlink" title="Ray tracing"></a>Ray tracing</h4><p>We cast rays from our eyes (camera) for each pixel and gather information of those rays as they travel<br>through/intersects with objects and interacts with lights<br>to form the final render on screen.</p><p>The fundamental of ray tracing is that for each pixel, we look at (shoot a ray) each object/geometry to see<br>how they contribute to the color of that pixel.</p><p>As for ray tracing, we need to shoot many rays for each pixel, and more when there are reflection and refraction.<br>One way to accelerate this is to use bounding volume.</p><p><img src="https://i.stack.imgur.com/e3SXv.png" alt="ray tracing"></p><h4 id="Discussion-1"><a href="#Discussion-1" class="headerlink" title="Discussion"></a>Discussion</h4><p>The most significant difference in visual is that ray tracing is physically more accurate<br>than rasterization, thus more realistic. Which is more apparent in dynamic environment with<br>objects that reflects and refract. Rasterization needs many estimation techniques to handle lighting and shadowing<br>such as more render passes, baked light map, cubemap reflection, but ray tracing gets all the results out of the box.</p><p><img src="https://i.stack.imgur.com/e9CSY.png" alt="rasterization vs. ray tracing"></p><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://gamedevelopment.tutsplus.com/articles/forward-rendering-vs-deferred-rendering--gamedev-12342">Envato tuts+ - Forward Rendering vs. Deferred Rendering</a></p><p><a href="https://learnopengl.com/Advanced-Lighting/Deferred-Shading">Learn OpenGL - Deferred Shading</a></p><p><a href="https://en.wikipedia.org/wiki/Deferred_shading#Deferred_lighting">Wikipedia - Deferred Lighting</a></p><p><a href="https://learnopengl.com/Lighting/Basic-Lighting">Learn OpenGL - Basic Lighting</a></p><p><a href="https://knowww.eu/nodes/59b8e93cd54a862e9d7e414a">Knowww - Per-vertex vs. per-fragment lighting</a></p><p><a href="https://answers.unity.com/questions/1749305">Unity Forum - What’s the difference between per-pixel and per-vertex lit in Forward Rendering?</a></p><p><a href="https://www.youtube.com/watch?v=dhVJE7g3hig">Youtube - OpenGL Fragment Shaders | How Do Fragment Shaders Work?</a></p><p><a href="https://developer.nvidia.com/blog/ray-tracing-essentials-part-2-rasterization-versus-ray-tracing/">Nvidia - Ray Tracing Essentials</a></p><p><a href="https://computergraphics.stackexchange.com/questions/4585">Stack Exchange - Mirror Reflections: Ray Tracing or Rasterization?</a></p><p><a href="https://www.quora.com/What-is-the-diferrence-between-ray-tracing-and-very-high-shader-details">Quora - What is the difference between ray tracing and very high shader details?</a></p>]]></content>
      
      
      <categories>
          
          <category> graphics programming </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rendering </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Comprehensive Guide to C++ Reference and Pointer</title>
      <link href="/cpp-reference-pointer/"/>
      <url>/cpp-reference-pointer/</url>
      
        <content type="html"><![CDATA[<h2 id="Basics"><a href="#Basics" class="headerlink" title="Basics"></a>Basics</h2><p><strong>De-referencing</strong></p><p>add * before a pointer to expose the object’s value it’s pointing</p><ul><li><code>varN</code>, varN’s value</li><li><code>ptrN</code>, varN’s address</li><li><code>*ptrN</code>, de-reference ptrN, varN’s value</li><li>(<code>&amp;ptrN</code>, ptrN’s address, which has little meaning)</li></ul><p><strong>Symbol to access a member of a class or class object (instance)</strong></p><ul><li><code>a-&gt;b</code>: <strong>b</strong> is the member of the object that pointer <strong>a</strong> refers to</li><li><code>a.b</code>: <strong>b</strong> is the member of the object, or the reference of an object <strong>a</strong></li><li><code>a::b</code>: <strong>b</strong> is the member of the class, or namespace <strong>a</strong></li></ul><h2 id="Declaration"><a href="#Declaration" class="headerlink" title="Declaration"></a>Declaration</h2><h3 id="Pointer-Declaration"><a href="#Pointer-Declaration" class="headerlink" title="Pointer Declaration"></a>Pointer Declaration</h3><p>Syntax: <code>varType* varName</code></p><p>Declaration<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//declare a c++ pointer to an integer</span></span><br><span class="line"><span class="type">int</span>* ptrx; </span><br></pre></td></tr></table></figure></p><p>Initialization<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a pointer pointing to address of varN, varN type should be int</span></span><br><span class="line"><span class="type">int</span> varN = <span class="number">9</span>;</span><br><span class="line"><span class="type">int</span>* ptrN;</span><br><span class="line">ptrN = &amp;varN;</span><br></pre></td></tr></table></figure></p><p>short-hand:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* ptrN = &amp;varN;  </span><br></pre></td></tr></table></figure></p><h3 id="Reference-Declaration"><a href="#Reference-Declaration" class="headerlink" title="Reference Declaration"></a>Reference Declaration</h3><p>Syntax: <code>varType&amp; varName</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span>&amp; invalidRef;   <span class="comment">// error: references must be initialized</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="type">int</span>&amp; ref = x; <span class="comment">// okay: reference to int is bound to int variable</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>When a reference is initialized with an object (or function), we say it is <strong>bound</strong> to that object (or function). The process by which such a reference is bound is called <strong>reference binding</strong></p><p>references must be bound to a <em>modifiable variable</em></p><h2 id="Function-Pass-Argument"><a href="#Function-Pass-Argument" class="headerlink" title="Function Pass Argument"></a>Function Pass Argument</h2><blockquote><p>Both of these methods are prevented copying the variable, and capable of modifying the variable value that is passed in; if a variable is expensive to copy, e.g. struct, class</p></blockquote><h3 id="By-Reference"><a href="#By-Reference" class="headerlink" title="By Reference"></a>By Reference</h3><ul><li><p>Modify the variable, can’t pass in an un-modifiable variable like <code>const</code></p><p>  Syntax <code>varType&amp; varName</code></p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">int</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; y &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Prevent modifying the variable, while having the benefit of not making a copy</p><p>  Syntax <code>const varType&amp; varName</code></p>  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printValue</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; y &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="By-Address-via-pointer"><a href="#By-Address-via-pointer" class="headerlink" title="By Address (via pointer)"></a>By Address (via pointer)</h3><p>Syntax <code>varType* varName</code>, to access the variable, de-reference using <code>*varName</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printByAddress</span><span class="params">(<span class="type">const</span> std::string* ptr)</span> <span class="comment">// The function parameter is a pointer that holds the address of str</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::cout &lt;&lt; *ptr &lt;&lt; <span class="string">&#x27;\n&#x27;</span>; <span class="comment">// print the value via the dereferenced pointer</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Function-Return-Argument"><a href="#Function-Return-Argument" class="headerlink" title="Function Return Argument"></a>Function Return Argument</h2><h3 id="Variable-Pointer"><a href="#Variable-Pointer" class="headerlink" title="Variable Pointer"></a>Variable Pointer</h3><p>works almost identically to return by reference, except a pointer to an object is returned instead of a reference to an object</p><p>The major advantage of return by address over return by reference is that we can have the function return <code>nullptr</code> if there is no valid object to return</p><h3 id="Variable-Reference"><a href="#Variable-Reference" class="headerlink" title="Variable Reference"></a>Variable Reference</h3><blockquote><p>Never return a reference to a local variable or some such, because it won’t be there to be referenced.</p></blockquote><p>Syntax <code>varType&amp; funName(args)</code></p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://stackoverflow.com/questions/4984600/when-do-i-use-a-dot-arrow-or-double-colon-to-refer-to-members-of-a-class-in-c">Stack Overflow - When do I use a dot, arrow, or double colon to refer to members of a class in C++?</a></p><p><a href="https://runestone.academy/ns/books/published/cpp4python/AtomicData/AtomicData.html#pointers">Runestone Academy - Pointers</a></p><p><a href="https://www.learncpp.com/cpp-tutorial/lvalue-references/">Learn C++ - Lvalue reference</a></p><p><a href="https://www.learncpp.com/cpp-tutorial/return-by-reference-and-return-by-address/">Learn C++ - Return by reference and return by address</a></p><p><a href="https://www.learncpp.com/cpp-tutorial/pass-by-lvalue-reference/">Learn C++ - Pass by lvalue reference</a></p><p><a href="https://www.learncpp.com/cpp-tutorial/pass-by-address/">Learn C++ - Pass by address</a></p>]]></content>
      
      
      <categories>
          
          <category> learning log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maya Python API Tutorial Series (3. Custom Deformer)</title>
      <link href="/maya-api-deformer/"/>
      <url>/maya-api-deformer/</url>
      
        <content type="html"><![CDATA[<h3 id="API-1-0-custom-deformer-Example"><a href="#API-1-0-custom-deformer-Example" class="headerlink" title="API 1.0 custom deformer Example"></a>API 1.0 custom deformer Example</h3><script src="https://gist.github.com/leixingyu/78352732cb52c6e797244755ade0bbfe.js"></script><p>Note: <code>MPxDeformerNode</code> is only available in API 2.0</p><p><strong>Custom Attribute vs. Built-in Attribute</strong></p><p>In the last chapter, we know how to create custom numeric type attribute using <code>MFnNumericAttribute</code>.<br>Sometimes in our node, we want to access existing built-in attribute.<br>We do so by using <code>OpenMayaMPx.cvar.MPxDeformerNode_(attributeName)</code> before Maya 2016,<br>we use <code>OpenMayaMPx.cvar.MPxGeometryFilter_(attributeName)</code> after 2016.</p><p><strong>Obtain Input Geometry</strong></p><p>In the sample code, we define our custom function <code>getDeformerInputGeom(self, dataBlock, geomIndex)</code><br>to obtain the input mesh to the deformer node. We will discuss this later.</p><p><strong>Accessory Node</strong></p><p>Accessory node acts like a secondary driver node connected to our deformer so they can influence the deformation. In the sample code, our accessory node is a locator which when we connects its world matrix, it will change our mesh’s deformation when translating.</p><p><strong>Custom Dependency Node vs. Custom Deformer Node</strong></p><p><strong>Registration:</strong><br>In our previous chapter, we register our node using <code>registerNode()</code> with<br>node type: <code>omMPx.MPxNode.kDependNode</code>,<br>in deformer node, we use <code>omMPx.MPxNode.kDeformerNode</code> as our node type.</p><p><strong>Inheritance:</strong><br>We now inherit our class from <code>omMPx.MPxDeformerNode</code> instead of <code>omMPxNode</code><br>there’s still <code>compute()</code> in <code>MPxDeformerNode</code> class,<br>but we want to write our deformation algorithm in <code>deform()</code>.</p><p><strong>Accessory Node:</strong><br><code>accessoryNodeSetup(self, dagModifier)</code> and <code>accessoryAttribute(self)</code> is override to allow us to control accessory node along with our deformer.</p><h2 id="Procedure"><a href="#Procedure" class="headerlink" title="Procedure"></a>Procedure</h2><h3 id="Step-1-Declare-attributes-Same-as-last-chapter"><a href="#Step-1-Declare-attributes-Same-as-last-chapter" class="headerlink" title="Step 1: Declare attributes (Same as last chapter)"></a>Step 1: Declare attributes (Same as last chapter)</h3><h3 id="Step-2-Initialize-Node"><a href="#Step-2-Initialize-Node" class="headerlink" title="Step 2: Initialize Node"></a>Step 2: Initialize Node</h3><p><strong>Node Creator</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nodeCreator</span>():</span><br><span class="line">    <span class="keyword">return</span> mpx.asMPxPtr(MyDeformer())</span><br></pre></td></tr></table></figure></p><p>Only API 1.0 is available.</p><p><strong>Node Initializer</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nodeInitializer</span>():</span><br><span class="line">    <span class="comment"># 1: create reference to numericAttribute and matrixAttribute function sets</span></span><br><span class="line">    numericAttrFn = om.MFnNumericAttribute()</span><br><span class="line">    matrixAttrFn = om.MFnMatrixAttribute()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2: create attribute using the function set</span></span><br><span class="line">    MyDeformer.inNumAttr = numericAttrFn.create(<span class="string">&#x27;num&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, om.MFnNumericData.kFloat, <span class="number">0.0</span>)</span><br><span class="line">    numericAttrFn.setMin(-<span class="number">1.0</span>)</span><br><span class="line">    numericAttrFn.setMax(<span class="number">1.0</span>)</span><br><span class="line">    numericAttrFn.setReadable(<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">    MyDeformer.inMatAttr = numericAttrFn.create(<span class="string">&#x27;matrix&#x27;</span>, <span class="string">&#x27;m&#x27;</span>)</span><br><span class="line">    matrixAttrFn.setStorable(<span class="literal">False</span>)</span><br><span class="line">    matrixAttrFn.setConnectable(<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2.5: access built-in attribute using OpenMayaMpx.cvar.MPxGeometryFilter_outputGeom</span></span><br><span class="line">    outputGeom = mpx.cvar.MPxGeometryFilter_outputGeom</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 3: attach attribute</span></span><br><span class="line">    MyDeformer.addAttribute(MyDeformer.inNumAttr)</span><br><span class="line">    MyDeformer.addAttribute(MyDeformer.inMatAttr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4: add circuit (relationship in-&gt;out)</span></span><br><span class="line">    MyDeformer.attributeAffects(MyDeformer.inNumAttr, ouputGeom)</span><br><span class="line">    MyDeformer.attributeAffects(MyDeformer.inMatAttr, ouputGeom)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 5: make attribute paintable</span></span><br><span class="line">    cmds.makePaintable(nodeName, <span class="string">&#x27;weights&#x27;</span>, attrType=<span class="string">&#x27;multiFloat&#x27;</span>, shapeMode=<span class="string">&#x27;deformer&#x27;</span>)</span><br></pre></td></tr></table></figure><p>we access the output Geometry attribute so we can later add relationship to it.</p><p><strong>RegisterNode</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mplugin.registerNode(nodeName, nodeID, nodeCreator, nodeInitializer, om.MPxNode.kDeformNode)</span><br></pre></td></tr></table></figure><p><strong>De-registerNode</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mplugin.deregisterNode(nodeID)</span><br></pre></td></tr></table></figure><h3 id="Step-3-Initialize-Node-（Deform-Algorithm）"><a href="#Step-3-Initialize-Node-（Deform-Algorithm）" class="headerlink" title="Step 3: Initialize Node （Deform Algorithm）"></a>Step 3: Initialize Node （Deform Algorithm）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyNode</span>(om.MPxDeformNode):</span><br><span class="line">    inNumAttr = om.MObject()</span><br><span class="line">    inMatAttr = om.MObject()</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">om.MPxDeformNode.__init__(self)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">deform</span>(<span class="params">self, dataBlock, geomIterator, localToWorldMatrix, geomIndex</span>):</span><br><span class="line">        <span class="comment"># step 1: access built-in attribute value using attribute name and attribute handle</span></span><br><span class="line">        envelopeAttr = mpx.cvar.MPxGeometryFilter_envelope</span><br><span class="line">        envelopeHandle = dataBlock.inputValue(envelopeAttr)</span><br><span class="line">        envelopeValue = envelopeHandle.asFloat()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># step 1.5: access custom attribute value</span></span><br><span class="line">        inNumHandle = dataBlock.inputValue(MyDeformer.inNumAttr)</span><br><span class="line">        inNumValue = inNumHandle.asFloat()</span><br><span class="line"></span><br><span class="line">        <span class="comment"># step 1.55: access custom translate value connected to an accessory node</span></span><br><span class="line">        inMatHandle = dataBlock.inputValue(MyDeformer.inMatAttr)</span><br><span class="line">        inMatValue = inNumHandle.asMatrix()</span><br><span class="line">        transMatrix = om.MTransformationMatrix(inMatValue)  <span class="comment"># matrix type</span></span><br><span class="line">        translateValue = transMatrix.getTranslation(om.MSpace.kObject)  <span class="comment"># vector type</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># step 2: access input mesh</span></span><br><span class="line">        inputMesh = self.getDeformerInputGeom(dataBlock, geomIndex)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># step 2.5: access mesh normals</span></span><br><span class="line">        meshFn = om.MFnMesh(inputMesh)</span><br><span class="line">        normalVectorArray = om.MFloatVectorArray()  <span class="comment"># create float vector array to store normal vector</span></span><br><span class="line">        meshFn.getVertexNormals(<span class="literal">False</span>, normalVectorArray, om.MSpace.kObject)  <span class="comment"># (average normal or not?, the array to store, normal space)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># step 3: iterate the mesh vertices and deform it</span></span><br><span class="line">        newVertexPosArray = om.MPointArray()  <span class="comment"># to store new vertices position</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> geomIterator.isDone():</span><br><span class="line">            vertexPos = geomIterator.position()</span><br><span class="line">            vertexIndex = geomIterator.index()</span><br><span class="line">            normalVector = om.MVector(normalVectorArray[vertexIndex])</span><br><span class="line">            <span class="comment"># built-in function weightValue(dataBlock, geomIndex, vertexIndex)</span></span><br><span class="line">            weight = self.weightValue(dataBlock, geomIndex, vertexIndex)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># vertexPos.x = vertexPos.x + [calculation of normalVector.x and translateValue[0]] * envelopeValue * weight</span></span><br><span class="line">            newVertexPosArray.append(vertexPos)</span><br><span class="line">            geomIterator.<span class="built_in">next</span>()</span><br><span class="line">        geomIterator.setAllPositions(newVertexPosArray)</span><br></pre></td></tr></table></figure><ul><li>To access a value from an attribute, we use <code>handle = dataBlock.input/outputValue(MyNode.attr)</code></li></ul><ul><li>if we have a custom attribute <code>inNumAttr:</code> <ul><li><code>inNumHandle = dataBlock.inputValue(MyDeformer.inNumAttr)</code></li><li><code>inNumValue = inNumHandle.asFloat()</code></li></ul></li></ul><ul><li>if we have a built-in attribte <code>envelope</code>:<ul><li>we first get our attribute name <code>envelope</code></li><li><code>envelopeAttr = mpx.cvar.MPxGeometryFilter_envelope</code></li><li><code>envelopeHandle = dataBlock.inputValue(envelopeAttr)</code></li><li><code>envelopeValue = envelopeHandle.asFloat()</code></li></ul></li></ul><ul><li>To get normal for individual vertices on our input mesh,<br>we first need to obtain our input mesh using our own function:<br><code>getDeformerInputGeom(self, dataBlock, geomIndex)</code>.<br>And using mesh function set MeshFn’s <code>getVertexNormals()</code> we store the<br>normal vector in <code>om.MFloatVectorArray()</code> type array.</li></ul><ul><li>To deform our mesh: we use the geometry iterator to perform iteration on<br>each mesh vertex and re-calculate its position.<br>We combine the use of <code>geoIterator.position()</code> and<br><code>geomIterator.setPosition(point)</code> or <code>geomIterator.setAllPositions(pointArray)</code>.</li></ul><ul><li>To access weight value on each vertex, we use built-in<br>function <code>weightValue(dataBlock, geomIndex, vertexIndex)</code>.<br>In which, <code>geomIndex</code> is provided in <code>deform()</code> and <code>vertexIndex</code> is from <code>geomIterator</code>.</li></ul><h3 id="Step-3-1-Get-in-Mesh"><a href="#Step-3-1-Get-in-Mesh" class="headerlink" title="Step 3.1: Get in-Mesh"></a>Step 3.1: Get in-Mesh</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getDeformerInputGeom</span>(<span class="params">self, dataBlock, geomIndex</span>):</span><br><span class="line">    inputAttr = mpx.cvar.MPxGeometryFilter_input</span><br><span class="line">    inputHandle = dataBlock.outputArrayValue(inputAttr)  <span class="comment"># use outputArray instead of inputArray to avoid re-computation</span></span><br><span class="line">    inputHandle.jumpToElement(geomIndex)</span><br><span class="line">    inputElementHandle = inputHandle.outputValue()</span><br><span class="line"></span><br><span class="line">    inputGeomAttr = mpx.cvar.MPxGeometryFilter_inputGeom</span><br><span class="line">    inputGeomHandle = inputElementHandle.child(inputGeomAttr)  <span class="comment"># this is different from how we usually get handler</span></span><br><span class="line">    inputGeomMesh = inputGeomHandle.asMesh()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inputGeomMesh</span><br></pre></td></tr></table></figure><p>At this point, I can’t fully interpret the meaning of this segment.</p><h3 id="Step-4-Accessory-Node"><a href="#Step-4-Accessory-Node" class="headerlink" title="Step 4: Accessory Node"></a>Step 4: Accessory Node</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">accessoryNodeSetup</span>(<span class="params">self, dagModifier</span>):</span><br><span class="line">    <span class="comment"># step1: create the accessory node using the supplied dagModifier</span></span><br><span class="line">    locator = dagModifier.createNode(<span class="string">&#x27;locator&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># step2: access accessory node&#x27;s attribute(can&#x27;t use mplug type, has to be mobject type)</span></span><br><span class="line">    <span class="comment"># access dependency node function set</span></span><br><span class="line">    dependNodeFn = om.MFnDependencyNode(locator)</span><br><span class="line">    matrixPlug = dependNodeFn.findPlug(<span class="string">&#x27;worldMatrix&#x27;</span>)  <span class="comment"># this returns mplug type attribute, we need mobject type attribute</span></span><br><span class="line">    matrixAttr = matrixPlug.attribute()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># step3: connect mobject type(required) together</span></span><br><span class="line">    <span class="comment"># param: accessory node(mobject), accessory attr(mobject), deformer node(mobject: using self.thisMObject()), deformer attr(mobject)</span></span><br><span class="line">    mConnectStatus = dagModifier.connect(locator, matrixAttr, self.thisMObject(), MyDeformer.inMatAttr)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># now the accessory node&#x27;s worldMatrix is driving to the custom in-matrix of the deformer node</span></span><br><span class="line">    <span class="keyword">return</span> mConnectStatus</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">accessoryAttribute</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="comment"># returns the deformer node attribute connected</span></span><br><span class="line">    <span class="keyword">return</span> MyDeformer.inMatAttr</span><br></pre></td></tr></table></figure><p>The <code>dagModifer</code> is supplied in the accessory node. We use dagModifier’s connect function to<br>connect the accessory node’s attribute to our deformer node’s attribute.<br>In this case, we have accessory’s attribute: <code>worldMatrix</code><br>(a built-in attribute obtained from <code>MFnDependencyNode.findPlug())</code><br>and our custom defined <code>MyDeformer.inMatAttr</code>.</p><p>One thing to note is that, the <code>.connect()</code> only takes MObject which we cannot supply <code>MPlug</code> type<br>object <code>matrixPlug = ...findPlug(&#39;attributeName&#39;)</code>, we perform an additional step<br><code>matrixAttr = matrixPlug.attribute()</code> to get the MObject type attribute.</p><p>Now we supply <code>.connect()</code> with parameters: an accessory node (MObject type),<br>accessory node’s attribute (MObject type), deformer node (MObject type)<br>and deformer node’s attribute (MObject type) as follows:<br><code>mConnectStatus = dagModifier.connect(locator, matrixAttr, self.thisMObject(), MyDeformer.inMatAttr)</code></p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://www.chadvernon.com/maya-api-programming/">Chad Vernon - Maya API Programming</a></p>]]></content>
      
      
      <categories>
          
          <category> maya python api </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maya </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maya Python API Tutorial Series (1. Command Plugin with Flags)</title>
      <link href="/maya-api-command/"/>
      <url>/maya-api-command/</url>
      
        <content type="html"><![CDATA[<h2 id="“Flags”-vs-“Argument”"><a href="#“Flags”-vs-“Argument”" class="headerlink" title="“Flags” vs “Argument”"></a>“Flags” vs “Argument”</h2><p>Take this as an example: </p><p><code>cmds.group(&#39;circle1&#39;, &#39;sphere1&#39;, name=&#39;group1&#39;)</code></p><ul><li><code>circle1</code> and <code>sphere1</code> are arguments</li><li><code>name</code> is the flag and <code>group1</code> is the value</li></ul><p>Another example:</p><p><code>cmds.polyCube(sx=10, axis=[0, 0, 1])</code></p><ul><li><strong>no argument</strong> is specified</li><li><code>sx</code> is the flag’s short name,  <code>subdivisionX</code> is the flag’s long name</li><li><code>[0, 0, 1]</code> is axis flag’s value, each individual number is called parameters</li></ul><h2 id="Procedure"><a href="#Procedure" class="headerlink" title="Procedure"></a>Procedure</h2><h3 id="Step-1-Declare-flag-name-outside-the-class"><a href="#Step-1-Declare-flag-name-outside-the-class" class="headerlink" title="Step 1: Declare flag name outside the class"></a>Step 1: Declare flag name outside the class</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">firstFlagShortName = <span class="string">&#x27;-f&#x27;</span></span><br><span class="line">firstFlagLongName = <span class="string">&#x27;-first&#x27;</span></span><br><span class="line">secondFlagShortName = <span class="string">&#x27;-s&#x27;</span></span><br><span class="line">secondFlagLongName = <span class="string">&#x27;-second&#x27;</span></span><br><span class="line"><span class="comment"># more flags ...</span></span><br></pre></td></tr></table></figure><h3 id="Step-2-Add-flag-and-argument-in-syntax-creator-outside-of-class"><a href="#Step-2-Add-flag-and-argument-in-syntax-creator-outside-of-class" class="headerlink" title="Step 2:  Add flag and argument in syntax creator outside of class"></a>Step 2:  Add flag and argument in syntax creator outside of class</h3><p>(this syntax creator will be further included in the plugin initialize function)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">syntaxCreator</span>():</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    create a OpenMaya.MSyntax object to store flags and argument</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    syntax = om.MSyntax()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># add flags with short name, long name, and value type</span></span><br><span class="line">    syntax.addFlag(firstFlagShortName, firstFlagLongName, om.MSyntax.kDouble)</span><br><span class="line">    syntax.addFlag(secondFlagShortName, secondFlagLongName, (om.MSyntax.kDouble, om.MSyntax.kDouble, om.MSyntax.kDouble))</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># add more flags ...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># add argument using MSyntax.addArg() function</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># add argument is not discussed, refer to document later</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> syntax</span><br></pre></td></tr></table></figure><h3 id="Step-3-Parsing-flags-called-inside-the-class’s-doIt-function"><a href="#Step-3-Parsing-flags-called-inside-the-class’s-doIt-function" class="headerlink" title="Step 3:  Parsing flags, called inside the class’s doIt function"></a>Step 3:  Parsing flags, called inside the class’s <code>doIt</code> function</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">parseArguments</span>(<span class="params">self, args</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; </span></span><br><span class="line"><span class="string">    instantiate MArgParser object, self.syntax() refers to the syntax created in step 2</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    argData = om.MArgParser(self.syntax(), args)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># check if certain flags are set</span></span><br><span class="line">    <span class="keyword">if</span> argData.isFlagSet(firstFlagShortName):</span><br><span class="line">        firstValue = argData.flagArgumentString(firstFlagShortName, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">if</span> argData.isFlagSet(secondFlagShortName):</span><br><span class="line">        secondParam0 = argData.flagArgumentInt(secondFlagShortName, <span class="number">0</span>)</span><br><span class="line">        secondParam1 = argData.flagArgumentInt(secondFlagShortName, <span class="number">1</span>)</span><br><span class="line">        secondParam2 = argData.flagArgumentInt(secondFlagShortName, <span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># parse more flags ...</span></span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://www.chadvernon.com/maya-api-programming/">Chad Vernon - Maya API Programming</a></p>]]></content>
      
      
      <categories>
          
          <category> maya python api </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maya </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
